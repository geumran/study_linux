An update on live kernel patching

By Jake Edge
September 27, 2017
Linux Plumbers Conference

2017 linux plumbers conference(LPC)의 refereed tracek에서, Jiri Kosina는 라이브 커널 패치 기능에 대한 상황 및 계획에 대한 최신내용을 공유했다. 그 내용은 오랜 역사를 가진 리눅스 자체에 대한 것이였고 커널로 가는 다년간의 길을 가지고 있다. Kosina는 이 역사를 살펴보면서, 라이브 패칭을 위해 필요하지만 빠져 있는 기능과 한계에 대해서도 살펴봤다.
In the refereed track at the 2017 Linux Plumbers Conference (LPC), Jiri Kosina gave an update on the status and plans for the live kernel patching feature. It is a feature that has a long history—pre-dating Linux itself—and has had a multi-year path into the kernel. Kosina reviewed that history, while also looking at some of the limitations and missing features for live patching.

그가 말하길 동작중인 커널에 패치를 적용하는 것에 대한 첫번째 질문은 "왜 이기능이 필요한가?" 이다. 이 질문은 LWN의 기사나 다른 곳에서 코멘트로 많이 받던 질문이였다. 이 기능이 필요하게 된 주요 이유는 데이터 센터의 높은 가동 중단 비용이다. 이는 데이터 센터 운영자가 가동 중단에 의한 비용을 줄이기 위해 여러 달 전에 중단 계획을 수립하게 한다. 제로 데이 취약점의 경우에는 이런 시간이 허락되지 않는다. 라이브 커널 패치는 덜 급하게 계획되어 있는 중단 중에 커널을 업데이트할 수 있을 때까지 작은 보안 수정을 목표로 한다. 이것은 커널을 오랜시간동안 조금씩 교체하기 위한 기능이 아니라 커널의 취약성이 들어났을 때에 대한 비상조치이다.
The first question that gets asked about patching a running kernel is "why?", he said. That question gets asked in the comments on LWN articles and elsewhere. The main driver of the feature is the high cost of downtime in data centers. That leads data center operators to plan outages many months in advance to reduce the cost; but in the case of a zero-day vulnerability, that time is not available. Live kernel patching is targeted at making small security fixes as a stopgap measure until the kernel can be updated during a less-hurried, planned outage. It is not meant for replacing the kernel bit by bit over time, but as an emergency measure when the kernel is vulnerable.

역사
History

라이브패칭의 뒤에 숨겨진 아이디어의 역사는 적어도 1940년대까지 거슬러올라간다고 그가 말했다. 그는 Richard Feynman의 책 "Surely You're Joking, Mr.Feynman!"을 참조했다. 파인만은 그가 초기 proto-computer에서 동작하는 프로그램을 교체하기 위해 사용했던 시스템을 설명했다. 그는 프로그램에서 펀치카드의 특정 그룹을 색으로 구분했다. 그렇게 하면 그는 비파괴적인 방식으로 프로그램의 작은 서브셋을 교체할 수 있다. 그것이 라이브패칭의 시작이라고 Kosina가 말한다.
The history of the idea behind live patching goes back at least as far as the 1940s, he said. He referenced the classic Richard Feynman book Surely You're Joking, Mr. Feynman!, where Feynman described a system he used to change the program being run by early proto-computers. He color-coded certain groups of punch cards in the program. That way, he could replace a small subset of the program in a non-destructive way. That was the beginning of live patching, Kosina said.

리눅스에서의 라이브 패칭의 첫 구현은 2008년에 발표된 ksplice이다. 원래는 박사의 연구 프로젝트였다. 논문과 코드는 오픈소스 SW로 발표되었다. 메커니즘은 stop_machine()을 사용하여 커널을 중지한 다음 스택을 검사하여 패치가 현재 실행중인 작업을 방해하는지 확인한다. 패치중인 함수가 스택에서 발견되면 ksplice는 패치를 거부하고 추후에 다시 재시도한다.
The first implementation of live patching for Linux that he is aware of is ksplice, which was announced in 2008. It was originally a research project for a PhD. thesis and the code was released as open-source software. The mechanism used stop_machine() to stop the kernel, then inspected the stack to see if the patch would interfere with any task currently running. If the function being patched was found on the stack, ksplice refused to patch it and retried later.

그가 말하길 ksplice의 주요 기여중 하나는 바이너리 커널을 비교하여 자동으로 패치를 생성하는 것에 있다. 원래 커널 바이너리와 패치된 커널 바이너리를 비교한다. 간단한 코드 변화라도 인라인함수와 기타 최적화가 무엇이 실제로 바뀌었는지를 알기 어렵게 한다. ksplice 프로젝트는 2011년 오라클이 인수했으며 소스코드는 비공개로 바뀌었다. 여전히 오라클의 리눅스 배포판에서 쓰이고 있다.
One of the major contributions that ksplice made was in its automatic patch generation by comparing binary kernels, he said. The original kernel binary and the patched kernel binary were compared. Function inlining and other optimizations make it hard to know what actually will change even from a simple source code change. The ksplice project was acquired by Oracle in 2011 and the source code was closed; it is still used by the Oracle Linux distribution today.

SUSE 고객의 요청으로, Kosina는 대안적인 방법으로 2014에 릴리즈된 KGraft 개발을 시작했다. 거의 동시에 레드햇은 kpatch를 릴리즈했다. 둘다 라이브커널 패칭을 목표로 했지만 완전히 패치된 상태로 나아가는 다른 방법을 사용했다. Kpatch는 ksplice와 비슷해서 시스템을 중지시키고 상태를 체크했지만 그에 반해 KGraft는 lazy migration 테크닉을 사용해서 천천히 모든 프로세스들을 새로운 코드로 이주시킨다. lazy migration은 보통 완료되는데 수밀리가 소모된다.
Based on requests from SUSE customers, Kosina had been working on an alternative approach, kGraft, which was released in 2014. Around the same time, Red Hat released kpatch, which it had been working on; both were aimed at live kernel patching, but had different ways to to achieve convergence to a fully patched state. Kpatch was similar to ksplice, in that it stopped the system and inspected its state, while kGraft used a lazy migration technique to slowly migrate all processes to use the new code. That lazy migration normally takes just milliseconds to complete.

KGraft 패치는 수세에 의해 상업적으로 지원되며 수세의 upstream first 원칙을 위반했다고 말했다. 패치는 툴체인의 도움을 통해 수동으로 생성되며 자동으로 바이너리를 비교하는 것과 비교해서 장점을 가지고 있다. 자동생성된 패치라 할지라도 살펴볼 필요가 있다(그리고 to possibly adjust it)  예를 들어, 구조체가 변경될 필요가 있을때, 기존의 구조체가 직접 수정되어야 한다. 수동으로 패치를 생성하는데 도움을 주기 위해 여전히 더 많은 툴을 도입할 필요가 있다고 말했다.
The kGraft patches are commercially supported by SUSE, which violates the company's "upstream first" principle, he said. Patches are created manually, with the help of the toolchain, which has some advantages over automatic binary comparisons. Even with automatic generation, there is a need to look at the patch generated (and to possibly adjust it); for example, if a structure needs to change, existing versions of the structure need to be modified in place. There is still a need for more tooling to assist with the manual patch generation, he said.

참고로, Kosina는 CRIU(checkpoint/restore in userspace) 프로젝트가 일종의 라이브 패치를 수행활 수 있는 또 다른 방법이라고 지적했다. 어떤 경우에는, kexec()를 새로운 커널에 체크포인트 한 다음 모든 유저스페이스를 복원하는 것이 합리적일 수 있다. 그렇게 하면 완전히 새로운 커널로 변경할 수 있지만 즉시(또는 라이브로) 되지는 않는다. 그것은 또한 바람직하지 않지만 하드웨어를 재초기화할 수도 있다.
As a side note, Kosina pointed to the checkpoint/restore in user space (CRIU) project as another potential way to do a kind of live patching. For some use cases, it might make sense to checkpoint all of the user-space processes, kexec() to the new kernel, then restore all of user space. That would allow changing to a completely new kernel, but it would not be immediate (or live). It also would reinitialize the hardware, which may not be desirable.

그는 lazy migration scheme에 대한 좀 더 자세한 내용에 대해 설명했다. 패치가 만들어진 후, 커널에 진입했다가 나온 프로세스는 이제 "new universe"에 살고 있는 것으로 마킹되며 그 시점부터 패치된 함수를 사용할 수 있게 된다. 패치가 반영될 때에 커널에서 동작중인 프로세스는 함수의 이전 버전을 실행하고 있게 된다. trampoline 함수는 함수의 두 버전중 어느 것을 호출할 지를 결정하는데 사용된다. 커널 스레드는 함수 교체가 안전하게 완료될 수 있는 "안전지점" 으로 마킹되므로 바꾸기 어렵지 않다. 또한 long-sleeping 프로세스(i.e get_tty()에서 블러킹된 프로세스)는 찾기가 싶고 가짜 시그널을 보내서 new universe 플래그로 설정되고 다시 sleep에 진입하게 한다.
He went into a bit more detail on the lazy migration scheme. After the patch is made, a process that enters or leaves the kernel gets marked as now living in the "new universe", so it will always get the patched function from that point on. Anything that is running in the kernel at the time of the patch will end up running the old version of the code; a trampoline function is used to decide which of the two versions of the function to call. Kernel threads have been marked with "safe points" where the switch can be made, which turned out to not be that difficult, surprisingly. In addition, long-sleeping processes (e.g. blocking in get_tty()) are identified and sent a fake signal that simply has the effect of setting the new-universe flag and putting them back to sleep.

A meeting of the minds
경쟁 솔루션이 있기 때문에 뒤셀도르프의 2014 LPC에서의 미팅에서 이 문제에 대해 토론을 하기 위해 모였다. 각 솔루션이 제시되었고 개발자들은 하나의 통합체계로 병합하려는 계획을 세웠다. 이것은 ftrace위에서 간단한 API와 함께 최소한의 기반으로 시작했다. 라이브 패치는 교체가능한 함수리스트에 등록될 수 있으며 오직 적용가능한 제한된 세트의 패치타입만 지원가능했다. 이 코드는 2015년 2월에 mainline으로 머지되었다.
There were competing solutions, so a meeting was held at the 2014 LPC in Düsseldorf to discuss the matter. Each solution was presented and the developers came up with a plan to try to merge one unified scheme. It would start with a minimal base on top of Ftrace, with a simple API. Live patches could be registered with a list of functions to be replaced, and it only supported a limited set of patch types that could be applied. That was merged into the mainline in February 2015.

그 이후로 kpatch와 kgraft에서 아이디어를 뽑아 CONFIG_LIVEPATH 옵션으로 커널에 추가되었다. 기본적으로 lazy migration을 사용하지만 오랜시간 잠들어있는 프로세스들과 커널스레드를 위한 stack 검사도 포함되어있는 hybrid consistency model로 존재한다. 원래 이 기능은 x86 전용이였지만 s390과 powerpc-64, arm64도 추가되었다.
Since then, ideas have been cherry-picked from kpatch and kGraft to be added to the kernel under the CONFIG_LIVEPATCH option. There is now a combined, hybrid consistency model that uses lazy migration by default, but falls back to stack examination for long-sleeping processes and kthreads. Originally, the feature was x86-only, but it has been added to s390 and PowerPC-64, with ARM64 in the works.

스택 검사는 라이브패치 기능의 중요한 일부분이다. 안정적인 stack unwinding없이 일관성을 제공하는 것은 불가능하다. Josh Poimboeuf는 stack trace를 얻을 수 있는 안정적인 방법을 제공하기 위해 ORC unwinder를 만들었다. 또한 objtool(이전의 stacktool)이 추가되어 커널 어셈블리 코드에서도 유효한 stack trace를 얻을 수 있다.
The stack examination is a crucial piece of the feature; without reliable stack unwinding, it is impossible to provide consistency. Josh Poimboeuf created the ORC unwinder to provide a reliable way to get a stack trace. In addition, objtool (formerly stacktool) has been added to ensure that assembly language pieces of the kernel will also produce a valid stack trace.

신뢰할 수 있는 stack trace를 얻으려는 이전 노력들은 심각한 성능저하가 있는 프레임포인터나 신뢰할 수 없고 느린 DWARF 디버깅레코딩을 사용했다. ORC unwinder는 안정적으로 stack unwinding을 위해 필요한것 이상을 가진 DWARF의 stripped-down한 버전이다.4.14에 머지되었고 oops나 panic 출력에도 쓰일것이다. 지금까지는 x86_64에서만 사용가능했지만 다른 아키텍쳐에서 사용할 수 있도록 작업이 진행중이다. ORC unwidner는 쉽게 포팅될 수 있기 때문에 주요 작업은 objtool에 대한 것이라고 Kosina가 말했다.
Earlier efforts at getting reliable stack traces either used frame pointers, which had a severe performance penalty, or DWARF debugging records, which turned out to be unreliable and slow. ORC is effectively a stripped-down version of DWARF that has nothing more than is needed for reliable stack unwinding. The ORC unwinder was merged into 4.14 and will also be used for oops and panic output. So far, it is only available for x86_64, but is in progress for other architectures; the main work is on objtool, Kosina said, as the ORC unwinder is straightforward to port.

패치는 현재 hand-written하고 있지만 툴이 곧 완성될 것이다. 패치의 소스는 하나의 C 파일로 git에서 검토하고 저장할 수 있다. 패치는 새로운 함수를 생성하고 기존 커널 함수의 대체 함수로 선언한다. 패치는 loadable 커널 모듈로 컴파일되며 패치된 함수를 대체 함수로 등록하는 초기화함수를 가지고 있고 이런 변경을 활성화한다.
Patches are currently hand-written, though tools are coming. The source for a patch is a single C file, which makes it easy to review and to store in Git. It creates new functions and declares them as replacements for existing kernel functions; that gets compiled into a loadable kernel module that has an initialization function to register the replacements and then to enable those changes.

More to do
현재 이 기능에는 몇가지 제한 사항이 있다. 하나읭 데이터 구조의 변경이나 기존 요소의 의미에 대한 변경을 처리할 수 있는 방법이 없다. shadow 변수를 사용하여 기존 구조에 새 필드를 간단하게 추가하는 간단한 솔루션이 있을 수 있다. lazy migration과 유사한 "lazy state transformation"은 변경되는 데이터 구조를 다룰 수 있는 또다른 방법일 수 있다. 이전 구조와 새로운 구조 모두에서 동작하는 새로운 함수를 만들수 있다.
There are some limitations of the feature, currently. For one, there is no way to deal with data structure changes or changes to the semantics of existing elements. There may be a straightforward solution for simply adding a new field to an existing structure using shadow variables. A "lazy state transformation", analogous to lazy migration, may be another way to deal with changing data structures; new functions that can work with both the old and new structures could be created.

그러나 이러한 접근 방식에는 몇가지 문제가 여전히 존재한다. 많은 커널 자료구조는 처리에 문제가 되는 스핀락이나 뮤텍스 같은 독점 액세스 메카니즘으로 보여된다. locking rule을 패치의 일부로 변경해야 하는 경우 교착 상태를 피하기 어려울 수 있다. 또한 패치 콜백을 사용하여 패치 프로세스 중에 문제를 해결할 수 있는 방법을 제공하기 위한 시도가 있지만 기능을 사용하는데 주의가 필요하다.
There are still some problems with those approaches, however. Many kernel data structures are protected by exclusive access mechanisms, such as spinlocks and mutexes, which will be problematic to handle. If the locking rules need to change as part of the patch, it will be difficult to avoid deadlocks. There is also an effort to provide ways to fix things up during the patching process using patch callbacks, though that functionality will need to be used with some care.

생성된 패치가 일관성 모댈네에 있음을 검증하는데는 많은 어려움이 있다. 어떤 것들은 적합하지 않을 수 있다. 이는 현재 검사 및 추론을 통해 확인된다. 패치작성자를 위한 가이드가 도움이 될것이다. GCC가 수횅할 다양한 최적화에서 오는 combinatiorial explosion을 처리하기 위한 도구를 완성하기 위한 많은 작업이 진행중이다. 예를 들어 GCC는 모든 호출자를 알고 있는 경우 함수의 ABI를 변경할 수 있으므로 해당 기능에 대한 패치가 처리될 수 없다.(혹은 GCC의 -fipr-ra 옵션이 사용되서는 안된다) 많은 이런 종류의 문제가 자동으로 감지될거라고 Kosina가 말했다.
There are lots of traps in verifying that the patches created will still be within the consistency model; certain things just may not fit. That is currently verified through inspection and reasoning; a guide for patch authors has been started to help with that as well. There is a lot of work being done on tooling to help tame the combinatorial explosion that comes from different optimizations that GCC will perform. For example, GCC can change the ABI for functions if it knows about all of the callers, so patches to those functions cannot be handled (or the GCC -fipr-ra option must not be used). Many of those kinds of problems could be detected automatically, Kosina said.

Kprobe는 까다로운 또다른 영역이다. 기존의 kprobe를 새로운 함수로 전환하는 것은 쉽지 않다. 이로 인해 몇 가지 놀라운 일이 발생할 수도 있다. ftrace는 해당 코드와 같이 동작할 수 없으므로 어셈블리어로 직접 작성된 패치가 패치불가하기도 한다. 유저스페이스에서의 라이브패치는 아마도 가능하겠지만 훨씬 어려운 일이 될것이다. 한가지 예를 들면, 어플리케이션은 종종 GCC 외의 툴로 빌드되어 문제를 키운다. 또한 일관성을 보장할 수 있는 체크 포인트를 정의하는 것은 더 어렵다.
Kprobes are another tricky area. It is difficult to switch an existing kprobe to a new function, which may cause some surprises. There is also an inability to patch hand-written assembly code; Ftrace is not able to work with that code. User-space live patching is something that could perhaps be done, but is much more difficult. For one thing, user-space applications are often built with tools other than GCC, which expands the problem. In addition, it is harder to define a checkpoint where the consistency can be assured.

Kosina는 대화를 마친후에 몇가지 질문에 대해 답변했다. 커널 주소 공간 레이아웃 랜덤화(KASLR) 기능은 라이브 패치에 영향을 미치지 않는다. 반면에 loadable 모듈은 쉽게 처리할 수 없다. on-disk 버전의 모듈에 패칭하고 reload하는게 가장 좋은 방법일 수 있다. 모듈서명도 있다. 라이브 패치는 모듈이므로 서명된 모듈이 필요한 경우 로딩하기 전에 패치 자체에 서명해야 한다.
Kosina answered a few questions after the talk. The kernel address-space layout randomization (KASLR) feature has no impact on live patching. Loadable modules, on the other hand, are not easily handled. Patching the on-disk version of the module and causing a reload may be the best approach. Module signing also came up; live patches are modules, so if signed modules are required, the patch itself will need to be signed before it can be loaded.

[I would like to thank LWN's travel sponsor, The Linux Foundation, for assistance in traveling to Los Angeles for LPC.]
