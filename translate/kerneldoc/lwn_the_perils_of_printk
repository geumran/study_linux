The perils of printk() https://lwn.net/Articles/705938/

One might be tempted to think that there is little to be said about the kernel's printk() function; all it does, after all, is output a line of text to the console. But printk() has its problems. In a Kernel Summit presentation, Sergey Senozhatsky said that he is simply unable to use printk() in its current form. The good news, he said, is that it is not unfixable — and that there are plans for addressing its problems.
누군가는 커널의 printk() 함수의 문제에 대해서는 이야기할 게 별로 없다고 생각하도록 합리화할 수도 있다. 결국 이 작업은 콘솔에 텍스트 줄을 출력한다. 그러나 printk()에는 문제가 있다. Kernel Summit에서 Sergey Senozhatsky는 printk()를 현재의 형태로 사용할 수 없다고 말했다. 그가 말한 좋은 뉴스는 그것이 수정할 수 없지만 문제를 해결할 계획이 있다는 것이다.

Locking the system with printk()
printk()에 의한 시스템 락업

One of the biggest problems associated with printk() is deadlocks, which can come about in a couple of ways. One of those is reentrant calls. Consider an invocation of printk() that is preempted by a non-maskable interrupt (NMI). The handler for that NMI will, likely as not, want to print something out; NMIs are extraordinary events, after all. If the preempted printk() call holds a necessary lock, the second call will deadlock when it tries to acquire the same lock. That is just the sort of unpleasantness that operating system developers normally go far out of their way to avoid.
printk()와 관련된 가장 큰 문제 중 하나는 데드락(deadlock)이며, 두 가지 방법으로 발생할 수 있다. 그 중 하나는 재진입 호출이다. non-maskable 인터럽트 (NMI)에 의해 선점된 printk() 호출을 생각해보자. 보통은 그렇지 않겠지만 NMI 핸들러는 extraordinary 이벤트이기 때문에 무언가 출력하고자 할 수도 있다. 선점된 printk() 호출이 필요한 락을 잡고 있다면, 두번째 호출은 동일한 락을 잡으려 할때 데드락에 빠질 것이다.
이는 운영 체제 개발자가 일반적으로 피해야 할 길에서 멀어지는 일종의 unpleasantness 이다.

This particular problem has been solved; printk() now has a special per-CPU buffer that is used for calls in NMI context. Output goes into that buffer and is flushed after the NMI completes, avoiding the need to acquire the locks normally needed by a printk() call.
이 문제는 이미 해결되었다. printk()에는 이제 NMI 컨텍스트에서 사용되는 per-CPU 버퍼를 가지고 있다. printk를 통한 출력은 해당 버퍼로 들어가고 NMI가 완료된 후 플러시되므로 printk() 호출에 필요한 잠금을 획득 할 필요가 없다.

Unfortunately, printk() deadlocks do not end there. It turns out that printk() calls can be recursive, the usual ban on recursion in the kernel notwithstanding. Recursive calls can happen as the result of warnings issued from deep within the kernel; lock debugging was also listed as a way to create printk() calls at inopportune times. If something calls printk() at the wrong time, the result is a recursive call that can deadlock in much the same way as preempted calls.
안타깝게도 printk()의 데드락 문제는 여기서 끝나지 않는다. printk() 호출이 반복적으로 발생할 수 있다는 것이 밝혀졌다. 이런 상황은 일반적으로 커널에서 금지하는 것이다. 재귀 호출은 커널 내부 깊은곳에서 발생한 경고의 결과로 발생할 수 있다. lock 디버깅 기능또한 부적절한 시기에 printk() 호출을 유발하는 경우로 알려져있다.  뭔가 잘못된 시점에 printk()를 호출한 결과는 선점된 호출과 거의 같은 방식의 교착 상태가 된다.??

The problem looks similar to the NMI case, so it should not be surprising that the solution is similar as well. Sergey has a proposal to extend the NMI idea, creating more per-CPU buffers for printk() output. Whenever printk() wanders into a section of code where recursion could  [Sergey Senozhatsky] happen, output from any recursive calls goes to those buffers, to be flushed at a safe time. Two new functions, printk_safe_enter() and printk_safe_exit(), mark the danger areas. Perhaps confusingly, printk_safe_enter() does not mark a safe area; instead, it marks an area where the "safe" output code must be used.
이 문제는 NMI의 경우와 유사하므로 해결책이 비슷하다는 것은 놀라운 일이 아니다. Sergey는 NMI 아이디어를 확장하여 printk() 출력을 위한 per-cpu buffer를 늘리자는 제안을 했다. printk()가 재귀가 일어날 수있는 코드 섹션을 배회할 때마다 [재귀 호출]의 출력은 안전한 시간에 플러시되도록 해당 버퍼로 이동한다. 두가지 새로운 함수인 printk_safe_enter(), printk_safe_exit()는 위험영역을 표시한다. 아마 혼동스럽겠지만 printk_safe_enter()는 안전 영역을 표시하지 않는다. 대신 "안전한" 출력 코드를 사용해야하는 영역을 표시한다.

given that the per-CPU buffers are required in an increasing number of situations, Peter Zijlstra wondered whether printk() should just use the per-CPU buffer always. Sergey responded that this approach is under consideration.
점점 더 많은 상황에서 per-cpu buffer가 필요하다는 점을 감안할 때, Peter Zijlstra는 printk()가 per-cpu buffer만 사용해야하는지 궁금해했다. Sergey는 이 접근법은 고려 중이라고(1) 응답했다.

번역주 1) 접근법이 결정된게 아니라 고려중이라는 이야기.

Hannes Reinecke said that part of the problem results from the two distinct use cases for printk(): "chit-chat" and "the system is about to die now." The former type of output can go out whenever, while the latter is urgent. In the absence of better information, printk() must assume that everything is urgent, but a lot of problems could be solved by simply deferring non-urgent output to a safe time. Linus Torvalds pointed out that the log level argument should indicate which output is urgent, but Peter said that just deferring non-urgent output is not close to a full solution. The real problem, he said, is in the console drivers; this subject was revisited later in the session.
Hannes Reinecke는 문제의 일부가 print()의 두 가지 서로 다른 사용법인 "잡담" 과 "the system is about to die now" 라고 말했다. 전자의 경우는  출력로그를  언제든지 꺼낼 수 있지만 후자는 긴급하다. 더 나은 정보가 없다면 printk()는 모든 것이 긴급하다고 가정해야 하지만, 긴급하지 않은 출력을 안전한 시간으로 지연시킴으로써 많은 문제를 해결할 수 있다. 리누스 토발즈(Linus Torvalds)는 log level에 대한 인자가 출력로그가 긴급한지를 나타내야 한다고 지적했다. 하지만 피터는 긴급하지 않은 결과를 지연시키는 것은 완전한 해결책이 아니라고했다. 실제 문제는 콘솔 드라이버에 있다고 말했다. 이 주제는 세션의 뒷부분에서 재검토되었다.

One problem with deferring non-urgent output, Sergey said, is that the ordering of messages can be changed and it can be hard to sort them out again. Peter suggested that this was not much of a problem; Hannes said, rather forcefully, that printk() output has timestamps on it, so placing it back into the proper order should not be difficult. The problem there, according to Linus, is that timestamps are not necessarily consistent across CPUs; if a thread migrates, the ordering of its messages could be wrong.
Sergey는 긴박하지 않은 로그를 지연시키는 방법의 문제 중 하나는 메시지의 순서가 변경 될 수 있고 메시지를 다시 정렬하기가 어려울 수 있다는 것이다. 베드로는 이것이 큰 문제가 아니라고 제안했다. Hannes는 오히려 강력하게 printk() 출력에 타임 스탬프가 있기 때문에 적절한 순서로 다시 배치하는 것이 어렵지 않아야 한다고 말했다. 리누스(Linus)에 따르면 이 문제는 타임 스탬프가 CPU에서 반드시 일치하지 않는다는 점에서 문제 가된다. 스레드가 마이그레이션되면 메시지의 순서가 잘못 될 수 있다.

Petr Mladek, who joined Sergey at the front of the room, said that there is a problem with per-CPU buffers: they will almost necessarily be smaller than a single, global buffer, and can thus limit the amount of output that can be accumulated. So it is more likely that the system will lose messages if it is using per-CPU buffers. It was pointed out that the ftrace subsystem has solved this problem for a long time, but it was also pointed out that the cost of that solution is a lot of complicated ring-buffer code. Linus said that the one thing that must be carefully handled is oops messages resulting from a kernel crash; those must make it immediately to the console.
petr mladek, whow joined sergey at the front of the room, per-cpu buffer가 문제가 된다고 말하면서, 이는 거의 반드시 단일 글로벌 버퍼보다 작을 것이므로 누적 될 수있는 출력의 양을 제한 할 수 있다고 한다. 따라서 per-cpu buffer를 사용하는 경우 시스템이 메시지를 잃을 가능성이 더 크다. ftrace 하위 시스템이 이 문제를 오랫동안 해결했지만, 그 솔루션의 비용은 많은 복잡한 링 버퍼 코드라는 지적이있었다. 리누스는주의 깊게 다루어 져야 할 한 가지는 커널 충돌로 인한 메시지라는 것이다. 그것들은 즉시 콘솔에 출력되어야 한다.

Sergey went on to say that there is a larger set of printk() deadlocks that needs to be dealt with. Thus far, the conversation had concerned "internal" locks that are part of printk() itself. But printk() often has to acquire "external" locks in other parts of the kernel. The biggest problem area appears to be sending output to the console; there are locks and related problems in various serial drivers that can, once again, deadlock the system. Unlike internal locks, external locks are not controlled by printk(), so the problem is harder to solve.
세르게이(Sergey)는 더 많은 printk() 교착 상태가 다루어 져야한다고 말한다. 지금까지의 대화는 printk() 자체의 일부인 "내부"잠금에 관련되어있었다. 그러나 printk()는 종종 커널의 다른 부분에서 "외부"잠금을 획득해야한다. 가장 큰 문제 영역은 출력을 콘솔에 보내는 것 같다. 여러 가지 직렬 드라이버에 잠금 및 관련 문제가있어 시스템을 교착 상태로 만들 수 있다. 내부 잠금과 달리 외부 잠금은 printk()에 의해 제어되지 않으므로 문제를 해결하기가 더 어렵다.

The kernel already has a printk_deferred() function that goes out of its way to avoid taking external locks, once again deferring output to a safer time. Sergey's proposal is to make printk() always behave like printk_deferred(), eliminating the distinction between the two and enabling the eventual removal of printk_deferred() itself. The only exception would be for emergency output, which will always go directly to the console. Linus suggested going one step further, and taking the deferred path even in emergencies, but then flushing the buffers immediately thereafter.
커널은 이미 printk_deferred() 함수를 가지고 있다.이 함수는 외부 잠금을 피하기 위해 빠져 나오고, 다시 한번 출력을 더 안전한 시간으로 연기한다. Sergey의 제안은 printk()가 항상 printk_deferred()처럼 동작하도록 만들어서 두 속성 사이의 차이를 제거하고 printk_deferred() 자체의 최종 제거를 가능하게하는 것이다. 유일한 예외는 항상 콘솔에 직접 연결되는 비상 출력이다. Linus는 한 단계 더 나아가 비상 사태시에도 지연된 경로를 취한 후 즉시 버퍼를 플러시 할 것을 제안했다.

Console troubles and more
Locks are not the only problem with printk(), though. To output its messages, it must call into the console drivers and, at completion, it must call console_unlock() which will, among other things, flush any pending output to the console. This function has some unfortunate properties: it can loop indefinitely, it may not be preemptible, and the time it takes depends on the speed of the console — which may not be fast at all. As a result, nobody knows how long a printk() call will take, so it's not really safe to call it in any number of situations, including atomic context, RCU critical sections, interrupt context, and more.
Lock은 printk()에서 유일한 문제는 아니다. 메시지를 출력하려면 콘솔 드라이버를 호출해야하며 완료되면 console_unlock()을 호출해야 한다.이 명령은 콘솔에서 보류중인 출력을 플러시한다. 이 함수는 불행한 속성을 가지고 있다. 즉, 루프가 무한정 반복 될 수 있고, 선점되지 않을 수 있으며, 소요되는 시간은 콘솔의 속도에 따라 달라진다. 결과적으로 아무도 printk() 호출이 얼마나 오래 걸릴지 아무도 알지 못하므로 원자 상황, RCU 임계 섹션, 인터럽트 컨텍스트 등을 포함한 여러 상황에서 호출하는 것이 안전하지 않다.

To get around this kind of problem, Jan Kara has proposed making printk() completely asynchronous. Once again, output would be directed to a buffer and sent to the console later, but, with this proposal, the actual writing to the console would be done in a dedicated kernel thread. A call to printk() would simply store the message, then use the irq_work mechanism to kick off that thread. This suggestion passed by without much in the way of complaints from the group in the room.
이런 종류의 문제를 해결하기 위해 Jan Kara는 printk()를 완전한 비동기로 만들것을 제안했다. 다시 한번, 출력은 버퍼로 전달되어 나중에 콘솔로 보내지만,이 제안을 통해 콘솔에 실제로 쓰는 것은 전용 커널 스레드에서 수행된다. printk()에 대한 호출은 단순히 메시지를 저장 한 다음 irq_work 메커니즘을 사용하여 해당 스레드를 시작한다. 이 제안은 사람들의 별 불만 없이 전달되었다.

Then, there is the problem of pr_cont(), a form of printk() used to print a single line using multiple calls. This function is not safe on SMP systems, with the result that output generated with it can be mixed up and corrupted. There is a strong desire to get rid of the "continuation line" style of printing, but, as Sergey pointed out, the number of pr_cont() calls in the kernel is growing rapidly. The problem, as Linus pointed out, is that there is no other convenient way to output variable-length lines in the kernel. Changing pr_cont(), to use a per-CPU buffer, for example, is possible, but one would want to create a well thought-out helper function. Then, perhaps, pr_cont() users could be easily fixed up with a Coccinelle script.
그런 다음 여러 호출을 사용하여 한 줄을 인쇄하는 데 사용되는 print ()의 한 형태 인 pr_cont() 문제가 있다. 이 기능은 SMP 시스템에서는 안전하지 않으므로 SMP 시스템에서 생성 된 출력이 혼합되어 손상 될 수 있다. Sergey가 지적했듯이, 커널의 pr_cont() 호출 수가 급속히 증가하고있는 중 "연속 라인"인쇄 스타일을 없애려는 강한 바람이 있다. 리누스(Linus)가 지적한 것처럼, 커널에서 가변 길이 라인을 출력하는 다른 편리한 방법은 없다. 예를 들어, per-cpu buffer를 사용하기 위해 pr_cont()를 변경하는 것도 가능하지만 잘 정의 된 helper 함수를 만들려는 것이 좋다. 그런 다음 아마도 pr_cont () 사용자는 Coccinelle 스크립트로 쉽게 수정 될 수 있다.

Ted Ts'o asked how much of a problem interleaved output really is on a production system; the consensus seemed to be that it was rarely a problem. Linus said that, on occasion, he sees ugly oops output as a result of continuation lines. Andy Lutomirski said, with a grin, that his algorithm for dealing with interleaved oops output is to wait for Linus to straighten it out for him. That solution seemed to work for the group as a whole; there does not seem to be any work planned in this area in the immediate future.
Ted Ts'o는 인터리빙 된 출력물이 실제로 생산 시스템에 얼마나 많은 문제가 있는지 묻는다. 합의는 그것이 거의 문제가되지 않는 것처럼 보였다. Linus는 때때로, 계속 선의 결과로 추악한 oops 산출을 본다고 말했다. 앤디 루토미르스키 (Andy Lutomirski)는 웃음과 함께, 인터 리브 된 oops 산출물을 다루기위한 그의 알고리즘은 리누스가 그를 위해 곧바로 그것을 기다리기를 기다리는 것이라고 말했다. 그 해결책은 그룹 전체에서 효과가있는 것처럼 보였다. 당장 이 분야에서 계획된 일이없는 것 같았다.

The final topic, covered in a bit of a hurry at the end of the session, was the console_sem semaphore. This semaphore covers access to all consoles in the system, so it is a global contention point. But there are paths that acquire console_sem that do not need to modify the console list or even write to a console. For example, simply reading /proc/consoles from user space will acquire that semaphore. That can cause unpleasant delays, including in printk() itself. And releasing this semaphore, once again, results in a call to console_unlock(), with the same associated problems.
마지막 주제는 console_sem 세마포어였다. 이 세마포어는 시스템의 모든 콘솔에 대한 액세스를 다루므로 전역적으로 contention이 발생하는 지점이다. 하지만 콘솔 목록을 수정하거나 콘솔에 쓸 필요가없는 console_sem을 획득하는 경로가 있다. 예를 들어, 사용자 공간에서 /proc/console을 읽는 것은 그 세마포어를 획득 할 것이다. 이로 인해 printk() 자체를 포함하여 좋지않은 지연이 발생할 수 있다. 이 세마포어를 다시 릴리스하면 동일한 문제가있는 console_unlock()이 호출된다.

Sergey suggested that console_sem should be turned into a reader/writer lock. That way, any path that does not need to modify the console list itself can acquire the lock in reader mode, increasing parallelism. That still won't help direct callers of console_unlock(), who will still be stuck flushing output to the device. For them, there was discussion of splitting console_unlock() into synchronous and asynchronous versions; the latter would just wake the printk() thread rather than flushing any pending console output itself. There does not appear to be any urgency to this work, though.
Sergey는 console_sem이 reader/writer lock으로 바뀌어야 한다고 제안했다. 이렇게하면 콘솔 목록 자체를 수정할 필요가없는 모든 경로가 읽기  모드에서 잠금을 획득 할 수있어 병렬성이 증가한다. 그래도 console_unlock()의 호출자를 직접 도울 수는 없으며, 여전히 콘솔에 출력이 계속 출력된다. 그들에게는 console_unlock()을 동기 및 비동기 버전으로 분할하는 것에 대한 논의가 있었다. 후자는 대기중인 콘솔 출력 자체를 플러시하지 않고 printk() 스레드를 깨울뿐이다. 그러나 이 작업은 그리 급해보이지 않는다.

That is where time ran out and the session ended. Sergey's slides are available for those who are interested.
그것이 시간이 다되어서 세션이 끝난 곳이다. Sergey의 슬라이드는 관심이있는 사람들에게 제공된다.
